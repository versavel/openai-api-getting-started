Advanced C++ for Robotics
Unit 4:   Object Oriented Programming (OOP)
- Summary -

Estimated time to completion: 4 hours

As per our learning of object-oriented programming from unit 3, we are about to dive deeper into the topic. Throughout the course, you will be asked to learn and implement the concepts as we at The Construct believe in learning by practice. Make sure you go through demos and exercise thoroughly, in case of doubts or guidance you can ask for help on our forums. So, let me quickly brief you with what topics we are about to learn:

    Composition
    Inheritance
    Function Overriding and function overloading
    Virtual Keyword
    Abstract Classes
    Interfaces
    Polymorphism
    TypeCasting

- End of Summary -

Let's briefly touch on why OOP is important in programming.

Object Oriented Programming is a way of writing code such that it is reusable. The concept follows the philosophy of DRY which means Don't Repeat Yourself. In this unit, we will discuss additional concepts crucial to OOP. Here are a few reasons for using OOP over procedural programming:

    OOP provides a clear modular structure for programs
    Easy maintenance and modification of existing code
    OOP provides a good framework for code libraries where supplied software components can be easily adapted and modified by the programmer.
    Improves code reusability and favourable for real-world problems.

It's time to dive deeper into the topic. Let's understand each topic and put them to use to write effective code.
4.1   Composition

In composition, a class uses an object of another class and follows a “has-a” relationship. Let me explain has-a relationship with a few examples. Mobile has-a screen, mobile has-a speaker, mobile has-a battery. “Has-a” implies screen(i.e. a simple object) is a part of mobile(a complex object made up of simple objects). In OOP, classes are written such that they are easy to maintain. Thus it is prefered to have a class that focuses on just one functionality. For example, to make a class named mobile, simpler classes such as battery, screen, speakers are used. When any changes are to be made in battery settings, the change is to be only made in battery class.

Therefore, this concept of complex objects is being used in most real-world scenarios. The advantages of using this concept are: an individual class can be straightforward. One class has a dedicated task and obtains one behaviour. The class is easier to write, debug, understand and usable by other programmers. While simpler classes can perform all the operations, the complex class can be designed to coordinate the data flow between the simpler classes. Easy to understand as a complex object only delegates tasks to sub-objects, who already know how to do them.
Demo 4.1

#include <iostream>

class Battery {

private:
    int num;

public:
    void set(int charge)
    {
        num = charge;
    }
    int get()
    {
        return num;
    }
};


class Mobile {

public:
    Battery battery1;
    
    void show()
    {
        std::cout<< "Battery is "<< battery1.get() <<"% charged"<< std::endl;
    }
};


int main()
{
    // create object of class Mobile
    Mobile nokia;
    nokia.battery1.set(100);
    nokia.show();
}

Expected Output:

Battery is 100% charged

End of Demo 4.1
- Exercise 4.1.1 -

In this exercise you will create a RobotManager class that will be able to inform the total CPU load and total memory usage that a robot is currently experiencing.

Notice how the capability to read the total CPU load and total memory usage is not limited to computers running in robots. We could perfectly want to use this capability on any computing device, such as a desktop computer or server. Therefore we will create an indepentent class named ComputerUnit class that can get performance metrics of any computing device.

Then, by using composition we will integrate an object of this class into a different object of class RobotManagerComposition, in such a way that the RobotManagerComposition class will now be able to inform the total CPU load and total memory usage of the robot.

Since the ComputerUnit class is going to be technically inside of the RobotManagerComposition class we are going to start off creating the ComputerUnit class first.
Part 1: Define a ComputerUnit class to read the total CPU load and total memory usage

In this part you will define an object that keeps track about various computer system performance metrics such as current total CPU load and total memory usage. This object includes methods to retrieve that information from the system as well as output that information to the console.

We will create this object because it in part 2 we want this object to be part of another object, namely an object of the already mentioned RobotManagerComposition class. Let's go!

Tasks:

    To start you will have to create a new ROS package called robot_manager_composition and make it depend on roscpp and std_srvs. This is the package where we will put all the files related to this exercise.

    Inside this new package we will create a new class named ComputerUnit. Below you are provided with the complete code for this part.

  Execute in Shell #1

cd ~/catkin_ws/src

catkin_create_pkg robot_manager_composition roscpp std_srvs

touch ~/catkin_ws/src/robot_manager_composition/include/robot_manager_composition/system_information.h

We have written out the code already:

  system_information.h

#ifndef CPU_INFO_COMPUTERUNIT_H
#define CPU_INFO_COMPUTERUNIT_H

#include <cstdint>

class ISystemInformation {
public:
  ISystemInformation() = default;
  virtual ~ISystemInformation() = default;
  virtual int64_t GetTotalMemory() = 0;
  virtual int64_t GetTotalUsageMemory() = 0;
  virtual double GetCpuTotalUsage() = 0;
};

class SystemInformation : public ISystemInformation {

public:
  SystemInformation();
  virtual ~SystemInformation() override;

  int64_t GetTotalMemory() override;
  int64_t GetTotalUsageMemory() override;
  double GetCpuTotalUsage() override;

private:
  struct PImpl;

  PImpl *m_impl;
};

class ComputerUnit {

private:
  long max_memory;
  long mem_usage;
  double cpu_sys_usage;
  double mem_usage_percentage;

public:
  ComputerUnit() {
    SystemInformation sys_info;

    max_memory = sys_info.GetTotalMemory();
    mem_usage = sys_info.GetTotalUsageMemory();
    cpu_sys_usage = sys_info.GetCpuTotalUsage();
  }
  void print_info();
};

#endif // CPU_INFO_COMPUTERUNIT_H

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_composition/src/system_information.cpp

  system_information.cpp

#include "robot_manager_composition/system_information.h"
#include <iostream>
#include "sys/sysinfo.h"
#include "sys/times.h"
#include "sys/types.h"
#include "sys/vtimes.h"
#include <cstdio>
#include <cstdlib>
#include <cstring>

void ComputerUnit::print_info() {
  printf("Total CPU usage: %.2f%%\n", cpu_sys_usage);
  try {
    auto mem_usage_percentage = (float)mem_usage / (float)max_memory * 100.0;
    printf("Total memory usage: %.2f%%\n", mem_usage_percentage);
  } catch (std::logic_error e) {
    std::cerr << e.what();
  }
}


struct SystemInformation::PImpl : public ISystemInformation {
public:
  PImpl() = default;

  ~PImpl() override = default;

  int64_t GetTotalMemory() override {
    struct sysinfo memInfo;

    sysinfo(&memInfo);
    long long totalPhysMem = memInfo.totalram;
    // Multiply in next statement to avoid int overflow on right hand side...
    totalPhysMem *= memInfo.mem_unit;

    return totalPhysMem;
  }

  int64_t GetTotalUsageMemory() override {
    struct sysinfo memInfo;

    sysinfo(&memInfo);
    long long physMemUsed = memInfo.totalram - memInfo.freeram;
    // Multiply in next statement to avoid int overflow on right hand side...
    physMemUsed *= memInfo.mem_unit;

    return physMemUsed;
  }

  double GetCpuTotalUsage() override {
    double percent;
    FILE *file;
    unsigned long long totalUser, totalUserLow, totalSys, totalIdle, total;

    file = fopen("/proc/stat", "r");
    fscanf(file, "cpu %llu %llu %llu %llu", &totalUser, &totalUserLow,
           &totalSys, &totalIdle);
    fclose(file);

    if (totalUser < m_lastTotalUser || totalUserLow < m_lastTotalUserLow ||
        totalSys < m_lastTotalSys || totalIdle < m_lastTotalIdle) {
      // Overflow detection. Just skip this value.
      percent = -1.0;
    } else {
      total = (totalUser - m_lastTotalUser) +
              (totalUserLow - m_lastTotalUserLow) + (totalSys - m_lastTotalSys);
      percent = total;
      total += (totalIdle - m_lastTotalIdle);
      percent /= total;
      percent *= 100;
    }

    m_lastTotalUser = totalUser;
    m_lastTotalUserLow = totalUserLow;
    m_lastTotalSys = totalSys;
    m_lastTotalIdle = totalIdle;

    return percent;
  }

private:
  void init() {
    FILE *file = fopen("/proc/stat", "r");
    fscanf(file, "cpu %llu %llu %llu %llu", &m_lastTotalUser,
           &m_lastTotalUserLow, &m_lastTotalSys, &m_lastTotalIdle);
    fclose(file);
  }

private:
  unsigned long long m_lastTotalUser;
  unsigned long long m_lastTotalUserLow;
  unsigned long long m_lastTotalSys;
  unsigned long long m_lastTotalIdle;
};


SystemInformation::SystemInformation() { m_impl = new PImpl(); }

SystemInformation::~SystemInformation() noexcept { delete m_impl; }

int64_t SystemInformation::GetTotalMemory() { return m_impl->GetTotalMemory(); }

int64_t SystemInformation::GetTotalUsageMemory() {
  return m_impl->GetTotalUsageMemory();
}

double SystemInformation::GetCpuTotalUsage() {
  return m_impl->GetCpuTotalUsage();
}

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_composition/src/system_information_test_executable.cpp

  system_information_test_executable.cpp

#include "robot_manager_composition/system_information.h"

int main() {

  ComputerUnit computer_unit1;

  computer_unit1.print_info();

  return 0;
}

  CMakeLists.txt

cmake_minimum_required(VERSION 3.0.2)
project(robot_manager_composition)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_srvs
)

catkin_package(
#  INCLUDE_DIRS include
## LIBRARIES ${PROJECT_NAME}
#  CATKIN_DEPENDS roscpp std_srvs
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

# Add standalone executable file
add_executable(system_information_test src/system_information_test_executable.cpp src/system_information.cpp)
target_link_libraries(system_information_test ${catkin_LIBRARIES})

  Execute in Shell #1

cd ~/catkin_ws && catkin_make

source devel/setup.bash

rosrun robot_manager_composition system_information_test

If your output is similar to the example below, then your ComputerUnit class works OK.

Total CPU usage: 40.44%
Total memory usage: 76.36%

Part 2:

In this part you must create a new RobotManagerComposition class inside the package robot_manager_composition. Initially, this class will only start a ROS Service server that will enable or disable console output.

Tasks:

    Create a header file robot_manager_composition.h located inside the /include/robot_manager_composition directory and the implementation file robot_manager_composition.cpp which should be located inside the src directory.

    In /src create a new file robot_manager_composition_node.cpp where you will add the main function and the code needed to start a ROS node and an instance of the RobotManagerComposition class.

    Create a boolean member variable called output_enabled to keep track of the enabled or disabled console output status.

    Add a service server that takes messaged of type std_srvs/SetBool and advertises a service named robot_manager_output.

    Upon incoming services requests the member variable output_enabled is changed accordingly.

    Finally edit the CMakeLists.txt to add an executable called robot_manager_composition_node to be built from the source files src/robot_manager_composition_node.cpp and src/robot_manager_composition.cpp.

    Once you have completed all the above tasks compile your package to make sure your code has no errors.

Compile and run the executable created:

  Execute in Shell #1

rosrun robot_manager_composition robot_manager_composition_node

Execute you code and verify that the service is available.

  Execute in Shell #2

rosservice list

And test your service, for example, if your service name is /robot_manager_output run:

  Execute in Shell #2

rosservice call /robot_manager_output "data: true"

rosservice call /robot_manager_output "data: false"

When using the above proposed callback method you should get:

  Output in Shell #2

success: True
message: "Console output enabled."

and:

success: True
message: "Console output disabled.

Part 3

In this part of the exercise we want to use an object of class ComputerUnit inside the class RobotManagerComposition and access the function for printing the CPU and RAM usage from inside the latter.

Tasks:

To start modify robot_manager_composition.h file:

    Declare a second parametrized constructor with two arguments: one of type ros::NodeHandle * and the other one of type ComputerUnit. Also don't forget to include the RobotManagerComposition class header.
    Add a private member variable to store an object of type ComputerUnit.

Then modify robot_manager_composition.cpp file:

    Add the definition for the new constructor so the program knows how it is implemented.
    Connect the new member variable to the internally used field.
    Modify the ConfigOutputCallback method to print out the CPU and RAM information when the console output is enabled.

Finally modify robot_manager_composition_node.cpp:

    Create and object of class ComputerUnit.
    Pass it to the constructor of RobotManagerComposition.

Run the executable:

  Execute in Shell #1

rosrun robot_manager_composition robot_manager_composition_node

[ INFO] [1677282558.271367174]: Enable output service created

  Execute in Shell #2

rosservice call /robot_manager_output "data: true"

  Output in Shell #2

success: True
message: "Console output enabled."

  Output in Shell #1

[ INFO] [1677282644.435152646, 8975.501000000]: Robot Manager console output enabled.
Total CPU usage: 44.08%
Total memory usage: 85.23%

Extra Exercise (optional)

This part is optional:
Implement the ComputerUnit class in a independent ROS package so it can be used separately from the RobotManagerComposition class in any other ROS package.
- End of Exercise 4.1.1 -
- Solution for Exercise 4.1.1 -
Part 1

Do as described in the task description.
Part 2

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_composition/include/robot_manager_composition/robot_manager_composition.h

  robot_manager_composition.h

#pragma once
#include <ros/ros.h>
#include <std_srvs/SetBool.h>

class RobotManagerComposition {

public:
  RobotManagerComposition(){};
  RobotManagerComposition(ros::NodeHandle *node_handle);


protected:
  ros::NodeHandle *nh;
  void init_config_output_srv();
  bool output_enabled = false;

private:
  ros::ServiceServer config_output_srv;
  bool ConfigOutputCallback(std_srvs::SetBoolRequest &req,
                            std_srvs::SetBoolResponse &response);
};

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_composition/src/robot_manager_composition.cpp

  robot_manager_composition.cpp

#include "robot_manager_composition/robot_manager_composition.h"
#include <ros/ros.h>

RobotManagerComposition::RobotManagerComposition(ros::NodeHandle *node_handle) {
  nh = node_handle;
  init_config_output_srv();
}

void RobotManagerComposition::init_config_output_srv() {
  config_output_srv = nh->advertiseService(
      "robot_manager_output", &RobotManagerComposition::ConfigOutputCallback, this);
  ROS_INFO("Enable output service created");
}

bool RobotManagerComposition::ConfigOutputCallback(
    std_srvs::SetBoolRequest &req, std_srvs::SetBoolResponse &response) {
  bool request = req.data;

  // Check if request is same as current output configuration
  if (request == output_enabled) {
    response.success = false;
    response.message = "Output configuration request is the same as the "
                       "current output configuration.";
    return true;
  }

  response.success = true;
  output_enabled = request;
  if (output_enabled == false) {
    response.message = "Console output disabled.";
    ROS_INFO("Robot Manager console output disabled.");
  } else {
    response.message = "Console output enabled.";
    ROS_INFO("Robot Manager console output enabled.");
  }
  return true;
}

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_composition/src/robot_manager_composition_node.cpp

  robot_manager_composition_node.cpp

#include "robot_manager_composition/robot_manager_composition.h"
#include <ros/ros.h>

int main(int argc, char **argv) {
  ros::init(argc, argv, "robot_manager_using_composition");
  ros::NodeHandle nh;
  RobotManagerComposition rm = RobotManagerComposition(&nh);
  ros::spin();
}

  CMakeLists.txt

Append the following snippet to the bottom of the CMakeLists.txt file.

add_executable(robot_manager_composition_node src/robot_manager_composition_node.cpp src/robot_manager_composition.cpp)
target_link_libraries(robot_manager_composition_node ${catkin_LIBRARIES})

To compile everything run:

  Execute in Shell #1

cd ~/catkin_ws && catkin_make

source devel/setup.bash

Execute it with:

  Execute in Shell #1

rosrun robot_manager_composition robot_manager_composition_node

Expected output:

[ INFO] [1674214389.977317190]: Enable Output Service created

And test your service, for example, if your service name is /robot_manager_output run:

  Execute in Shell #1

rosservice call /robot_manager_output "data: true"

Stop execution using Ctrl+C
Part 3

Perform the changes shown below to extend the capability of the RobotManagerComposition class by using object composition.

  robot_manager_composition.h

#include "robot_manager_composition/system_information.h"

 RobotManagerComposition(ros::NodeHandle *node_handle, ComputerUnit computer_unit); 

private:
  ComputerUnit c_unit;

  robot_manager_composition.cpp

#include "robot_manager_composition/system_information.h"

RobotManagerComposition::RobotManagerComposition(ros::NodeHandle *node_handle,
                           ComputerUnit computer_unit) {
  nh = node_handle;
  init_config_output_srv();
  c_unit = computer_unit;
}

bool RobotManagerComposition::ConfigOutputCallback(std_srvs::SetBoolRequest &req,
                                        std_srvs::SetBoolResponse &response) {
  bool request = req.data;

  // Check if request is same as current output configuration
  if (request == output_enabled) {
    response.success = false;
    response.message = "Output configuration request is the same as the "
                       "current output configuration.";
    return true;
  }

  response.success = true;
  output_enabled = request;
  if (output_enabled == false) {
    response.message = "Console output disabled.";
    ROS_INFO("Robot Manager console output disabled.");
  } else {
    response.message = "Console output enabled.";
    ROS_INFO("Robot Manager console output enabled.");
    // Print CPU and RAM information
    c_unit.print_info();
  }
  return true;
}

  robot_manager_composition_node.cpp

To access the system information header file, insert the following line at the beginning of your code:

#include "robot_manager_composition/system_information.h"

Then replace this line here:

RobotManagerComposition rm = RobotManagerComposition(&nh);

By this:

    ComputerUnit computer_unit1;
    RobotManagerComposition rm = RobotManagerComposition&nh, computer_unit1);

Verify it builds without error and run to confirm it works as expected.

  CMakeLists.txt

Swap this line here:

add_executable(robot_manager_composition_node src/robot_manager_composition_node.cpp src/robot_manager_composition.cpp)

With this:

add_executable(robot_manager_composition_node src/robot_manager_composition_node.cpp src/robot_manager_composition.cpp  src/system_information.cpp)

As you see this adds the source code file src/system_information.cpp which was not there previously.

Once you have finished, shut your program down by hitting Ctrl+C in the console.
- End of Solution for Exercise 4.1.1 -
4.2   Inheritance

You might have come across the word inheritance. It is usually used in context of inherited characteristics, which is that in humans some characteristics are passed down from parent to child. For example, Harry (child) had an eye of his mother Lily (parent) and characteristic to attract trouble of his father (a reference to Harry Potter). We call it as Harry inherited his mother’s eyes and his father’s bravery. In the context of programming, inheritance means to use an existing parent class to create a derived child class that has the same member variables and methods but can also define its unique members.

Let us assume you have written a program to classify if the creature shown in an image is a bird (don’t forget Buckbeak was fictional :p ). Inside the code, you could write three functions as:

1) HasBeak()
2) HasWings()
3) TwoLegs()

Now, you are asked to write a new class to detect a parrot, a peacock and a sparrow. a) Either you write the above three functions for parrot, peacock and sparrow, or b) you make a parent class as a bird and derive three child classes for each bird.

Method b promotes reusability and avoids data redundancy. Now, there are ways in which you can inherit a class. They are:

    Single Inheritance
    Multiple Inheritance
    Multilevel Inheritance
    Hierarchical Inheritance
    Hybrid Inheritance

Let’s understand the concepts with a family analogy, mother and father are the base classes here (refer to the image to better understand the concept).

    Single Inheritance: the child has inherited characteristics just from his mother.
    Multiple Inheritance: the child has inherited characteristics from both of his parents.
    Multilevel Inheritance: the child has inherited characteristics of his father which were his grandad’s characteristics.
    Hybrid Inheritance: the child has characteristics of his father, grandfather (father is child class of grandfather class) and mother.
    Hierarchical Inheritance: the father has characteristics of his dad and mom, the mother has characteristics of her dad and mom and then the child has characteristics of father, mother, grandad (both maternal and paternal) and grandmom (both maternal and paternal).

Before we start to understand the concept with the help of a demo program, let’s recall the possible access specifiers for the child class. That is, in what way the child class will inherit the parent's class characteristics.

As we know from unit 3, there are three possible access specifiers, namely:

    public
    private, and
    protected

Parent Class has 3 possibilities to store data and child has 9 ways of inheriting data. Let me explain, public class of parents can be inherited by the recent child class as public or private or protected (3 possibilities just for public parents). I hope you could guess the remaining 6 types of inheritance now.

Let’s have a look at a visual representation in the form of a table.

It’s time to write some code and understand what we learnt.
Demo 4.2.1

Create a new directory:

  Execute in Shell #1

mkdir ~/unit4_demos

cd ~/unit4_demos

Create a new file named demo_411.cpp:

touch demo_411.cpp

Here's the code that produces the demo:

  demo_411.cpp

#include<iostream>
using namespace std;

class GrandDad{
    public:
        void Dfunc(){
        cout<<"GrandDad class is called"<<endl;
        }
};

class GrandMom{
    public:
        void Mfunc(){
        cout<<"GrandMom class is called"<<endl;
        }
};

class Father : public GrandDad{
    public:
        void Ffunc(){ 
            cout<<"Father class is called"<<endl;
        }
};
    
class Uncle  : public GrandDad, public GrandMom{
    public:
};
    
class You : public Father{
    public:
};

int main(){

Father Bob;
cout << "Bob is example of Single Inheritance"<<endl;
Bob.Dfunc();
Uncle Mario;
cout << "Mario is an example of Multiple Inheritance"<<endl;
Mario.Dfunc();
Mario.Mfunc();
You Tom;
cout<< "Tom is an example of MultiLevel Inheritance"<<endl;
Tom.Dfunc();
Tom.Ffunc();
return 0;
}

  Execute in Shell #1

clang++ demo_411.cpp -o demo_411

./demo_411

Expected Output:

Bob is example of Single Inheritance
GrandDad class is called
Mario is an example of Multiple Inheritance
GrandDad class is called
GrandMom class is called
Tom is an example of MultiLevel Inheritance
GrandDad class is called
Father class is called

End of Demo 4.2.1

Let's test your understanding of Inheritance with an exercise. Below is a code snippet. Guess the answer without compiling the code. Cross-check the answers to check your understanding.
- Exercise 4.2.1 -

#include<iostream>

class GrandDad{
    int age;
    protected:
      void run();
    public:
      void walk();
};

class Father: private GrandDad{
    int height;
    public:
      void sleep();
      void wake();
};
    
class You : public Father{
    int weight;
    public:
      void eat();
      void dance();
};

Questions:

1) What is the type of inheritance is involved when you initialize an object of class You?

2) Write names of all the members, which are directly accessible by the member function wake() of class Father.

3) Write names of all the members who are directly accessible by the member function dance() of class You.

4) Write the names of all the members who are directly accessible by the object Tom of class You declared in main().
- End of Exercise 4.2.1 -
- Solution for Exercise 4.2.1 -

Answers:

1) Multilevel inheritance (You inherits from Father which inherits from GrandDad).

2) Data members: height member function: run(),walk(),sleep(),wake()

3) weight, eat(), dance(),sleep(),wake()

4) sleep() wake () eat() and dance()
- End of Solution for Exercise 4.2.1 -
- Exercise 4.2.2 -

For the sake of clarity, create a new package robot_manager_inheritance and make it depend on roscpp, nav_msgs and std_srvs. This is the package where you need to put all your files related to this exercise.

  Execute in Shell #1

cd ~/catkin_ws/src

catkin_create_pkg robot_manager_inheritance roscpp nav_msgs std_srvs

The purpose of this exercise is to create a new Robot Manager program which has its functionality implemented into two classes:

    RobotManagerBase: the base class that implements functionality that is common to all types of robots, for instance mobile bases, aerial robots and robotic arms.

    RobotManagerMobile: the drived class that implements functionality that only applies to mobile bases.

Part 1

In the first part, you will complete the implementation of the base class.

Tasks:

    Create a header file base_robot_manager.h located inside the /include/robot_manager_inheritance directory and the implementation file base_robot_manager.cpp which should be located inside the src directory.

    Then create a base class RobotManagerBase, which should hold the boolean output_enabled to indicate if the robot manager console output is currently on or not. Initialize it to false since we don't want to print the output to the console at startup. Add a ROS Service Server to set that boolean variable. You will need to import this message type std_srvs/SetBool as the following: #include <std_srvs/SetBool.h>

    To create such a service create a ros::ServiceServer object and call it config_output_srv.

    Initialize the service server on a separate method that you can name init_config_output_srv(). The syntax to initialize that ros::ServiceServer object would look like this:

config_output_srv = nh->advertiseService("robot_manager_output", &RobotManagerBase::ConfigOutputCallback, this);

And the implementation for the service callback function could be as follows:

bool RobotManagerBase::ConfigOutputCallback(
    std_srvs::SetBoolRequest &req, std_srvs::SetBoolResponse &response) {
  bool request = req.data;

  // Check if request is same as current output configuration
  if (request == output_enabled) {
    response.success = false;
    response.message = "Output configuration request is the same as the "
                       "current output configuration.";
    return true;
  }

  response.success = true;
  output_enabled = request;
  if (output_enabled == false) {
    response.message = "Console output disabled.";
    ROS_INFO("Robot Manager console output disabled.");
  } else {
    response.message = "Console output enabled.";
    ROS_INFO("Robot Manager console output enabled.");
  }
  return true;
}

Tasks:

    In /src create a new file base_robot_manager_node.cpp where you will add the main function and the code needed to start a ROS node and an instance of the RobotManagerBase class.

    Finally edit CMakeLists.txt to add an executable called robot_manager_base_class_test_node to be built from the source files src/base_robot_manager_node.cpp and src/base_robot_manager.cpp.
    Note: This executable is only used for testing the base class and not for running the final program, which has to include the derived class.
    Once you have completed all the above tasks compile your package to make sure your code has no errors.

Run the executable created for testing the base class:

  Execute in Shell #1

rosrun robot_manager_inheritance robot_manager_base_class_test_node

Execute you code and verify that the service is available.

  Execute in Shell #2

rosservice list

And test your service, for example, if your service name is /robot_manager_output run:

  Execute in Shell #2

rosservice call /robot_manager_output "data: true"

rosservice call /robot_manager_output "data: false"

When using the above proposed callback method you should get:

success: True
message: "Console output enabled."

and

success: True
message: "Console output disabled."

Part 2

The purpose of this part is to create a minimal derived class RobotManagerMobile and call the methods of the base class through a derived class instance.

To start, create a new header file mobile_robot_robot_manager.h located inside /include/robot_manager_inheritance and two implementation files mobile_robot_robot_manager.cpp and mobile_robot_robot_manager_node.cpp which should be inside /src. Use the file mobile_robot_robot_manager_node.cpp only as starting point of the program, keeping the class implementation exclusively in the two other files.

Your main task is to write a sub-class RobotManagerMobile which is inherited through public inheritance from RobotManagerBase.

Points to consider:

    Assign the NodeHandle from the derived class to the corresponding base class variable.
    Call the parent class method to initialize the robot_manager_output service from part 1 that starts and stops the console output.
    Modify the CMakeLists.txt file to build the sources as an executable that you can call mobile_robot_robot_manager_node.

Once you have completed the above tasks and your code builds without errors, run it to verify that the service is available.

  Execute in Shell #1

rosrun robot_manager_inheritance mobile_robot_robot_manager_node

[ INFO] [1674215313.164629103]: Enable Output Service created
[ INFO] [1674215313.173386423]: Odometry subscriber created

  Execute in Shell #2

rosservice list

And test your service, for example, if your service name is /robot_manager_output run:

rosservice call /robot_manager_output "data: true"

rosservice call /robot_manager_output "data: false"

Part 3

Let's complete the derived class by adding the functionallity that only applies to mobile bases.

Inside the sub-class RobotManagerMobile add the following:

    A string variable odometry_topic that holds the odometry topic name. Use as default /robot1/odom.
    A subscriber to odometry that you initialize with odom_subscriber = nh->subscribe(odometry_topic, 1000, &OdomListener::odom_callback, this);
    A odometry callback function that prints the current robot position to the console if and only if the variable output_enabled from the base class is equal to true. Recall in Unit 3 we implemented such an callback function that you can adapt to make it work here. At that time the method signature was void RobotManager::odom_callback(const nav_msgs::Odometry::ConstPtr &msg).

As usual compile with catkin_make and the run your code with:

  Execute in Shell #1

rosrun robot_manager_inheritance mobile_robot_robot_manager_node

  Execute in Shell #2

To test your code, make a call on the robot_manager_output service and set the state of console output to true:

rosservice call /robot_manager_output "data: true"

You should start seeing the output of the odometry callback function.

[ INFO] [1649162850.134345386, 60.649000000]: Robot Manager output enabled.
[ INFO] [1649162850.197723604, 60.674000000]: Position (x,y): 0.000538 , 0.000027
[ INFO] [1649162850.251562207, 60.723000000]: Position (x,y): 0.000538 , 0.000027
[ INFO] [1649162850.336520032, 60.771000000]: Position (x,y): 0.000538 , 0.000028
[ INFO] [1649162850.455916732, 60.824000000]: Position (x,y): 0.000539 , 0.000028
[ INFO] [1649162850.542308679, 60.874000000]: Position (x,y): 0.000540 , 0.000026

Lastly test if you can stop the console output by running:

  Execute in Shell #2

rosservice call /robot_manager_output "data: false"

- End of Exercise 4.2.2 -
- Solution for Exercise 4.2.2 -
Part 1

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_inheritance/include/robot_manager_inheritance/base_robot_manager.h

  base_robot_manager.h

#pragma once
#include <ros/ros.h>
#include <std_srvs/SetBool.h>

class RobotManagerBase {

public:
  RobotManagerBase(){};
  RobotManagerBase(ros::NodeHandle *node_handle);

protected:
  ros::NodeHandle *nh;
  void init_config_output_srv();
  bool output_enabled = false;

private:
  ros::ServiceServer config_output_srv;
  bool ConfigOutputCallback(std_srvs::SetBoolRequest &req,
                            std_srvs::SetBoolResponse &response);
};

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_inheritance/src/base_robot_manager.cpp

  base_robot_manager.cpp

#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

RobotManagerBase::RobotManagerBase(ros::NodeHandle *node_handle) {
  nh = node_handle;
  init_config_output_srv();
}

void RobotManagerBase::init_config_output_srv() {
  config_output_srv = nh->advertiseService(
      "robot_manager_output", &RobotManagerBase::ConfigOutputCallback, this);
  ROS_INFO("Enable Output Service created");
}

bool RobotManagerBase::ConfigOutputCallback(
    std_srvs::SetBoolRequest &req, std_srvs::SetBoolResponse &response) {
  bool request = req.data;

  // Check if request is same as current output configuration
  if (request == output_enabled) {
    response.success = false;
    response.message = "Output configuration request is the same as the "
                       "current output configuration.";
    return true;
  }

  response.success = true;
  output_enabled = request;
  if (output_enabled == false) {
    response.message = "Console output disabled.";
    ROS_INFO("Robot Manager console output disabled.");
  } else {
    response.message = "Console output enabled.";
    ROS_INFO("Robot Manager console output enabled.");
  }
  return true;
}

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_inheritance/src/base_robot_manager_node.cpp

  base_robot_manager_node.cpp

#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

int main(int argc, char **argv) {
  ros::init(argc, argv, "robot_manager_using_inheritance");
  ros::NodeHandle nh;
  RobotManagerBase rmb = RobotManagerBase(&nh);
  ros::spin();
}

Modify the CMakeLists.txt file before you compile your code. Just overwrite the existing contents with this:

  CMakeLists.txt

cmake_minimum_required(VERSION 3.0.2)
project(robot_manager_inheritance)

find_package(catkin REQUIRED COMPONENTS
  nav_msgs
  roscpp
  std_srvs
)

catkin_package(
  INCLUDE_DIRS include
  LIBRARIES ${PROJECT_NAME}
  CATKIN_DEPENDS nav_msgs roscpp std_srvs
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

## Declare a C++ library
add_library(${PROJECT_NAME}
  src/base_robot_manager.cpp
)

## Specify libraries to link a library or executable target against
target_link_libraries(${PROJECT_NAME}
${catkin_LIBRARIES}
)

# Add standalone executable file
add_executable(robot_manager_base_class_test_node src/base_robot_manager_node.cpp src/base_robot_manager.cpp)
target_link_libraries(robot_manager_base_class_test_node ${catkin_LIBRARIES} ${PROJECT_NAME})

To compile everything run:

  Execute in Shell #1

cd ~/catkin_ws

catkin_make

source devel/setup.bash

Execute it with:

  Execute in Shell #1

rosrun robot_manager_inheritance robot_manager_base_class_test_node

Expected output:

[ INFO] [1674214389.977317190]: Enable Output Service created

Stop execution using Ctrl+C
Part 2

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_inheritance/include/robot_manager_inheritance/mobile_robot_robot_manager.h

  mobile_robot_robot_manager.h

#pragma once
#include "nav_msgs/Odometry.h"
#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

class MobileRobotRobotManager : public RobotManagerBase {

public:
  MobileRobotRobotManager(ros::NodeHandle *node_handle);

};

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_inheritance/src/mobile_robot_robot_manager.cpp

  mobile_robot_robot_manager.cpp

#include "robot_manager_inheritance/mobile_robot_robot_manager.h"
#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

MobileRobotRobotManager::MobileRobotRobotManager(ros::NodeHandle *node_handle) {
  // assign NodeHandle to nh variable from parent class
  nh = node_handle;
  init_config_output_srv();
}

  Execute in Shell #1

touch ~/catkin_ws/src/robot_manager_inheritance/src/mobile_robot_robot_manager_node.cpp

  mobile_robot_robot_manager_node.cpp

#include "robot_manager_inheritance/mobile_robot_robot_manager.h"
#include <ros/ros.h>

int main(int argc, char **argv) {
  ros::init(argc, argv, "robot_manager");
  ros::NodeHandle nh;
  MobileRobotRobotManager mrrm = MobileRobotRobotManager(&nh);
  ros::spin();
}

Below the existing add_executable() and target_link_libraries() calls, add the lines:

  CMakeLists.txt

# add new standalone executable file
add_executable(mobile_robot_robot_manager_node
  src/mobile_robot_robot_manager_node.cpp
  src/mobile_robot_robot_manager.cpp
  src/base_robot_manager.cpp)

target_link_libraries(mobile_robot_robot_manager_node ${catkin_LIBRARIES} ${PROJECT_NAME})

Verify it builds without error.
Part 3

  mobile_robot_robot_manager.h

#pragma once
#include "nav_msgs/Odometry.h"
#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

class MobileRobotRobotManager : public RobotManagerBase {

public:
  MobileRobotRobotManager(ros::NodeHandle *node_handle);
  void odom_callback(const nav_msgs::Odometry::ConstPtr &msg);

private:
  void init_odom_subscriber();
  float current_x_position = 0.0;
  float current_y_position = 0.0;
  std::string odometry_topic = "/robot1/odom";
  ros::Subscriber odom_subscriber;
};

  mobile_robot_robot_manager.cpp

#include "robot_manager_inheritance/mobile_robot_robot_manager.h"
#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

MobileRobotRobotManager::MobileRobotRobotManager(ros::NodeHandle *node_handle) {
  // assign NodeHandle to nh variable from parent class
  nh = node_handle;
  init_config_output_srv();
  init_odom_subscriber();
}

void MobileRobotRobotManager::init_odom_subscriber() {
  odom_subscriber = nh->subscribe(
      odometry_topic, 1000, &MobileRobotRobotManager::odom_callback, this);
  ROS_INFO("Odometry subscriber created");
}

void MobileRobotRobotManager::odom_callback(
    const nav_msgs::Odometry::ConstPtr &msg) {
  if (output_enabled) {
    current_x_position = msg->pose.pose.position.x;
    current_y_position = msg->pose.pose.position.y;
    ROS_INFO("Position (x,y): %lf , %lf", current_x_position,
             current_y_position);
  }
}

Compile with catkin_make and execute.

  Execute in Shell #1

rosrun robot_manager_inheritance mobile_robot_robot_manager_node

Rember to hit CTRL+C to stop it and to be able to run the upcoming course exercises.
- End of Solution for Exercise 4.2.2 -
4.3   Function Overriding & Function Overloading

Function Overloading: This feature of the C++ language, the same name of the function is used by differing its number or name of arguments. By doing so, the same function can be used to behave differently under different circumstances.
Demo 4.3.1

#include <iostream>
#include <string>


// method 1
void mobile(int var)
{
    std::cout << "Charge available " << var << std::endl;
}

// method 2
void mobile(std::string s)
{
    std::cout << "Battery Status: "<< s << std::endl;
}


int main()
{
    int a = 96;
    std::string status ="Charging";

    mobile(a);
    mobile(status);

    return 0;
}

Expected Output:

Charge available 96
Battery Status: Charging

End of Demo 4.3.1

Function Overriding: Using this method, you can redefine a function of Parent Class by defining function differently in the child class. In overriding arguments passed to the function should be the same. Overriding is needed when the derived class(child class) function has to do some added or different job than the base class function.
Demo 4.3.2

#include<iostream>
using namespace std;

class Mobile
{
public:
    virtual void Display()
    {
        cout << "\nThis is Display() method"
                " of base class Mobile"<<endl;
    }
    void Show()
    {
        cout << "\nThis is Show() method "
            "of BaseClass Mobile"<<endl;
    }
};

class VideoPlayer : public Mobile
{
public:
    // Overriding method - new working of
    // base class's display method
    void Display()
    {
        cout << "\nThis is Display() method"
            " of derived Class VideoPlayer"<<endl;
    }
};

// Driver code
int main()
{
    VideoPlayer Vp;
    Mobile &M = Vp;
    M.Display();
    Vp.Show();
}

Expected Output:

This is Display() method of derived Class VideoPlayer

End of Demo 4.3.2
4.4   Virtual Function

A virtual function is a member function defined in the base class and redefined (overridden) when in need, in the derived class. You can call the virtual function by declaring a pointer to the base class and using an object of the derived class. So by referring to a derived class object using the pointer, you call a virtual function.

Virtual functions are important as they make sure the correct function is called for an object. Here, resolving of function or which function should be called is done at the runtime. The prototype of virtual functions should be the same in the base as well as the derived class. A class may have a virtual constructor but it cannot have a virtual destructor.
Demo 4.4

#include<iostream>

class Father {
public:
    virtual void run()
    {
        std::cout << "Father is running" << std::endl;
    }
};

class Son : public Father {
public:
    void run()
    {
        std::cout << "Son is running" << std::endl;
    }

};

int main()
{
    Father father;
    Son son;

    father.run();
    son.run();

    return 0;
}

Expected Output:

Father is running
Son is running

End of Demo 4.4
- Exercise 4.4 -

In Exercise 4.2.2 your wrote a typical example of inheritance. In this exercise you will modify that program in order to include a regular virtual function.
Let's get started!

Part I: Declare a virtual function in the base class

Go to the code editor and open up the base_robot_manager.h and base_robot_manager.cpp files inside the robot_manager_inheritance package from Exercise 4.2.2.

Tasks

    Add a std::string protected member variable robot_name to keep the name of the robot.
    Add a second std::string protected member variable robot_location to store where the robot is located.
    Initialize the above variables to a hard-coded name and location of your choice.
    Add a new virtual method void displayRobotDetails() and use it to display the robot name and location to the screen each time the ConfigOutputCallback() method gets triggered. Use std::cout or ROS_INFO(), whichever suits you best.

Compile your code and run the executable that we created to test the base class:

  Execute in Shell #1

rosrun robot_manager_inheritance robot_manager_base_class_test_node

Test the /robot_manager_output service and confirm the robot details are printed to screen.

  Execute in Shell #2

rosservice call /robot_manager_output "data: true"

rosservice call /robot_manager_output "data: false"

When using the above proposed callback method you should get:

  Output in Shell #2

success: True
message: "Console output enabled."

and

  Output in Shell #2

success: True
message: "Console output disabled."

Additionally in WebShell #1 you should see the robot name and location printed out to the console.
Notice this is just an example, your otuput is probably slightly different.

  Output in Shell #1

[ INFO] [1649337647.229293471]: Enable Output Service created
[ INFO] [1649330069.471218739]: Robot Name: Waste Allocation Load Lifter Earth-Class
[ INFO] [1649330069.471286873]: Robot Location: Emeryville, California
[ INFO] [1649330069.471318803]: Robot Manager console output enabled.

and when disabling the console output:

  Output in Shell #1

[ INFO] [1649330099.470260905]: Robot Name: Waste Allocation Load Lifter Earth-Class
[ INFO] [1649330099.470311011]: Robot Location: Emeryville, California
[ INFO] [1649330099.470343853]: Robot Manager console output disabled.

Part II: Override the virtual function behaviour in the derived class

Open up the files mobile_robot_robot_manager.h and mobile_robot_robot_manager.cpp from Exercise 4.2.2 in your code editor.

Tasks

    Modify the derived class: Add two private instance variables battery_charge_level (of type float) and type_of_battery (of type std::string) with default values of 0.55 and Lead acid batteries respectively.
    Override the displayRobotDetails() method in the derived class to display the battery_charge_level and type_of_battery in addition to the information that was displayed by the method in the base class.

Compile your code and run the executable that creates the derived class object:

  Execute in Shell #1

rosrun robot_manager_inheritance mobile_robot_robot_manager_node

  Execute in Shell #2

rosservice call /robot_manager_output "data: true"

rosservice call /robot_manager_output "data: false"

When using the above proposed callback method you should get:

  Output in Shell #2

success: True
message: "Console output enabled."

and

  Output in Shell #2

success: True
message: "Console output disabled."

Additionally in WebShell #1 you should see the robot name, location, battery charge level and type of battery printed out to the console.
Notice this is just an example, your otuput is probably slightly different.

  Output in Shell #1

[ INFO] [1649337647.229293471]: Enable Output Service created
[ INFO] [1649337647.239991102]: Odometry subscriber created
[ INFO] [1649337653.683163023]: Robot Name: Waste Allocation Load Lifter Earth-Class
[ INFO] [1649337653.683397388]: Robot Location: Emeryville, California
[ INFO] [1649337653.683586535]: Battery Charge Level: 0.550000
[ INFO] [1649337653.683646119]: Type of Battery: Lead acid batteries
[ INFO] [1649337653.683697607]: Robot Manager console output enabled.

and when disabling the console output:

  Output in Shell #1

[ INFO] [1649337809.629286854]: Robot Name: Waste Allocation Load Lifter Earth-Class
[ INFO] [1649337809.629363212]: Robot Location: Emeryville, California
[ INFO] [1649337809.629427262]: Battery Charge Level: 0.550000
[ INFO] [1649337809.629465888]: Type of Battery: Lead acid batteries
[ INFO] [1649337809.629533386]: Robot Manager console output disabled.

- End Of Exercise 4.4 -
- Solution for Exercise 4.4 -

Part I: Declare a virtual function in the base class

You must use the virtual keyword for the base class function declaration, i.e. in front of displayRobotDetails(). This is technically necessary. But this must be done only inside the class declaration (base_robot_manager.h file), not where you have the function definition (base_robot_manager.cpp file).

  base_robot_manager.h

#pragma once
#include <ros/ros.h>
#include <std_srvs/SetBool.h>

class RobotManagerBase {

public:
  RobotManagerBase(){};
  RobotManagerBase(ros::NodeHandle *node_handle);

protected:
  ros::NodeHandle *nh;
  void init_config_output_srv();
  bool output_enabled = false;
  virtual void displayRobotDetails();
  std::string robot_name = "Waste Allocation Load Lifter Earth-Class";
  std::string robot_location = "Emeryville, California";

private:
  ros::ServiceServer config_output_srv;
  bool ConfigOutputCallback(std_srvs::SetBoolRequest &req,
                            std_srvs::SetBoolResponse &response);
};

We must add the function definition for displayRobotDetails() to the corresponding base class .cpp file:

  base_robot_manager.cpp

#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

RobotManagerBase::RobotManagerBase(ros::NodeHandle *node_handle) {
  nh = node_handle;
  init_config_output_srv();
}

void RobotManagerBase::init_config_output_srv() {
  config_output_srv = nh->advertiseService(
      "robot_manager_output", &RobotManagerBase::ConfigOutputCallback, this);
  ROS_INFO("Enable Output Service created");
}

bool RobotManagerBase::ConfigOutputCallback(
    std_srvs::SetBoolRequest &req, std_srvs::SetBoolResponse &response) {
  bool request = req.data;

  displayRobotDetails();

  // Check if request is same as current output configuration
  if (request == output_enabled) {
    response.success = false;
    response.message = "Output configuration request is the same as the "
                       "current output configuration.";
    return true;
  }

  response.success = true;
  output_enabled = request;
  if (output_enabled == false) {
    response.message = "Console output disabled.";
    ROS_INFO("Robot Manager console output disabled.");
  } else {
    response.message = "Console output enabled.";
    ROS_INFO("Robot Manager console output enabled.");
  }
  return true;
}
    
void RobotManagerBase::displayRobotDetails(){
    ROS_INFO("Robot Name: %s", robot_name.c_str());
    ROS_INFO("Robot Location: %s", robot_location.c_str());
}

Part II: Override the virtual function behaviour in the derived class

Note: The base class files base_robot_manager.h and base_robot_manager.cpp remain unchanged.

The virtual keyword is not necessary in the derived class.

  mobile_robot_robot_manager.h

#pragma once
#include "nav_msgs/Odometry.h"
#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

class MobileRobotRobotManager : public RobotManagerBase {

public:
  MobileRobotRobotManager(ros::NodeHandle *node_handle);
  void odom_callback(const nav_msgs::Odometry::ConstPtr &msg);

private:
  void init_odom_subscriber();
  float current_x_position = 0.0;
  float current_y_position = 0.0;
  std::string odometry_topic = "/robot1/odom";
  ros::Subscriber odom_subscriber;
  void displayRobotDetails();
  float battery_charge_level = 0.55;
  std::string type_of_battery = "Lead acid batteries";
};

Add a function definition for displayRobotDetails() to the derived class .cpp file:

  mobile_robot_robot_manager.cpp

#include "robot_manager_inheritance/mobile_robot_robot_manager.h"
#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

MobileRobotRobotManager::MobileRobotRobotManager(ros::NodeHandle *node_handle) {
  // assign NodeHandle to nh variable from parent class
  nh = node_handle;
  init_config_output_srv();
  init_odom_subscriber();
}

void MobileRobotRobotManager::init_odom_subscriber() {
  odom_subscriber = nh->subscribe(
      odometry_topic, 1000, &MobileRobotRobotManager::odom_callback, this);
  ROS_INFO("Odometry subscriber created");
}

void MobileRobotRobotManager::odom_callback(
    const nav_msgs::Odometry::ConstPtr &msg) {
  if (output_enabled == true) {
    current_x_position = msg->pose.pose.position.x;
    current_y_position = msg->pose.pose.position.y;
    ROS_INFO("Position (x,y): %lf , %lf", current_x_position,
             current_y_position);
  }
}

void MobileRobotRobotManager::displayRobotDetails() {
  ROS_INFO("Robot Name: %s", robot_name.c_str());
  ROS_INFO("Robot Location: %s", robot_location.c_str());
  ROS_INFO("Battery Charge Level: %f", battery_charge_level);
  ROS_INFO("Type of Battery: %s", type_of_battery.c_str());
}

- End of Solution for Exercise 4.4 -

Note: we can still can access the displayRobotDetails() function declared in the base class if we use the scope resolution operator ::. For instance in the example above you would need to call RobotManagerBase::displayRobotDetails(); instead of just displayRobotDetails();.
4.5   Abstract Class

By definition, an abstract class has at least one pure virtual function(equate virtual function to 0). Abstract classes find use as a base class when the implementation of derived classes is uncertain. For example, you want to construct a class that returns the area of the shape provided. Now, you know that the mathematical formula used to find the area for a square is different from the formula to find the area of a triangle. So, for each derived class the function area() will be different. Another rule to keep in mind while defining making use of the abstract class is: we must override the pure virtual function in the derived class, otherwise the derived class will also become an abstract class.

Let me explain the same thing with the help of a program.
Demo 4.5

#include <iostream>

using namespace std;

class Shape {
   public:
      //definition of a pure virtual function
      virtual int Area() = 0; 
      // Function to set dimension
      void setDimension(int w, int h) {
         width = w;
      height = h;
      }
     protected:
      int width;
      int height;
};

// A rectangle is a shape; it inherits shape.
class Rectangle: public Shape {
   public:
      int Area() { 
         return (width * height); 
      }
};
// A triangle is a shape; it inherits shape.
class Triangle: public Shape {
   public:
      // Observe the different return mathematical formula as per the need
      // We have use the same function of the base class
      int Area() { 
         return (width * height)/2; 
      }
};

int main() {
  Rectangle R;
  Triangle T;

  R.setDimension(2,4);
  T.setDimension(8,2);

  cout << "The area of the rectangle is: " << R.Area() << endl;
  cout << "The area of the triangle is: " << T.Area() << endl;
}

Expected Output:

The area of the rectangle is: 8
The area of the triangle is: 8

End of Demo 4.5
- Exercise 4.5 -

In this exercise we are going to continue where we left off working with virtual functions from Exercise 4.4. Once again, you will have to modify the files in the robot_manager_inheritance package.

Your task is to make all the necessary changes to make the member function displayRobotDetails() a pure virtual function.

Make sure your code compiles without errors.
Hint: you will very likely have to modify your CMakeLists.txt file. Take a moment to think about the why.

For this exercise the main test is checking if the code compiles. This isn't a joke.

If the compilation goes smoothly you can go a step further and check if the program still behaves as expected at runtime:

  Execute in Shell #1

rosrun robot_manager_inheritance mobile_robot_robot_manager_node

  Execute in Shell #2

rosservice call /robot_manager_output "data: true"

You should get:

  Output in Shell #2

success: True
message: "Console output enabled."

Additionally in WebShell #1 you should see the robot name, location, battery charge level and type of battery printed out to the console.
Notice this is just an example, your otuput is probably slightly different.

  Output in Shell #1

[ INFO] [1649337647.229293471]: Enable Output Service created
[ INFO] [1649337647.239991102]: Odometry subscriber created
[ INFO] [1649337653.683163023]: Robot Name: Waste Allocation Load Lifter Earth-Class
[ INFO] [1649337653.683397388]: Robot Location: Emeryville, California
[ INFO] [1649337653.683586535]: Battery Charge Level: 0.550000
[ INFO] [1649337653.683646119]: Type of Battery: Lead acid batteries
[ INFO] [1649337653.683697607]: Robot Manager console output enabled.

- End of Exercise 4.5 -
- Solution for Exercise 4.5 -

Declare a pure virtual function by using a pure specifier = 0 in the declaration of displayRobotDetails() in the class declaration:

  base_robot_manager.h

#pragma once
#include <ros/ros.h>
#include <std_srvs/SetBool.h>

class RobotManagerBase {

public:
  RobotManagerBase(){};
  RobotManagerBase(ros::NodeHandle *node_handle);

protected:
  ros::NodeHandle *nh;
  void init_config_output_srv();
  bool output_enabled = false;
  virtual void displayRobotDetails() = 0;
  std::string robot_name = "Waste Allocation Load Lifter Earth-Class";
  std::string robot_location = "Emeryville, California";

private:
  ros::ServiceServer config_output_srv;
  bool ConfigOutputCallback(std_srvs::SetBoolRequest &req,
                            std_srvs::SetBoolResponse &response);
};

You must remove the function definition for displayRobotDetails() from the base class .cpp file or you will get an error at compile time:

  base_robot_manager.cpp

#include "robot_manager_inheritance/base_robot_manager.h"
#include <ros/ros.h>

RobotManagerBase::RobotManagerBase(ros::NodeHandle *node_handle) {
  nh = node_handle;
  init_config_output_srv();
}

void RobotManagerBase::init_config_output_srv() {
  config_output_srv = nh->advertiseService(
      "robot_manager_output", &RobotManagerBase::ConfigOutputCallback, this);
  ROS_INFO("Enable Output Service created");
}

bool RobotManagerBase::ConfigOutputCallback(
    std_srvs::SetBoolRequest &req, std_srvs::SetBoolResponse &response) {
  bool request = req.data;

  displayRobotDetails();

  // Check if request is same as current output configuration
  if (request == output_enabled) {
    response.success = false;
    response.message = "Output configuration request is the same as the "
                       "current output configuration.";
    return true;
  }

  response.success = true;
  output_enabled = request;
  if (output_enabled == false) {
    response.message = "Console output disabled.";
    ROS_INFO("Robot Manager console output disabled.");
  } else {
    response.message = "Console output enabled.";
    ROS_INFO("Robot Manager console output enabled.");
  }
  return true;
}

The implementation of the files mobile_robot_robot_manager.h and mobile_robot_robot_manager.cpp remains unchanged.

  CMakeLists.txt

You will have to remove these two lines:

add_executable(robot_manager_base_class_test_node src/base_robot_manager_node.cpp src/base_robot_manager.cpp)
target_link_libraries(robot_manager_base_class_test_node ${catkin_LIBRARIES} ${PROJECT_NAME})

Why? because you can't build an executable file solely from the base class now as it has one pure virtual function displayRobotDetails() that is not defined anywhere but in the derived class.

The updated CMakeLists.txt for this package is:

cmake_minimum_required(VERSION 3.0.2)
project(robot_manager_inheritance)

find_package(catkin REQUIRED COMPONENTS
  roscpp
  std_srvs
  my_payload
)

catkin_package(
  INCLUDE_DIRS include
  LIBRARIES ${PROJECT_NAME}
  CATKIN_DEPENDS roscpp std_srvs
)

include_directories(
  include
  ${catkin_INCLUDE_DIRS}
)

## Declare a C++ library
add_library(${PROJECT_NAME}
  src/base_robot_manager.cpp
)

## Specify libraries to link a library or executable target against
target_link_libraries(${PROJECT_NAME}
${catkin_LIBRARIES}
)

# add standalone executable file
add_executable(mobile_robot_robot_manager_node
  src/mobile_robot_robot_manager_node.cpp
  src/mobile_robot_robot_manager.cpp
  src/base_robot_manager.cpp)

target_link_libraries(mobile_robot_robot_manager_node ${catkin_LIBRARIES} ${PROJECT_NAME})

- End of Solution for Exercise 4.5 -
4.6   Interfaces

An interface is a description of what member functions must a class, which inherits this interface, implement. In other words, an interface describes the behaviour of the class. You can imagine an interface as a list of functions that must be implemented by a class.

An interface can inherit functions from one or more base interfaces. It can contain only public member functions. In contrast, it cannot contain constructor, destructor, data members, and static member functions.

You can create an interface as an abstract class with public pure virtual functions that will follow the rules. However, __interface keyword enforces the properties mentioned.

Let’s see a demonstration of an abstract class being used as an interface.
Demo 4.6

#include<iostream>

// implement interface using abstract class
// interface contains only pure virtual member function
class IPower
{
  public:
  virtual void Square()=0;
  virtual void Cube()=0;
  ~IPower()=default;
};

class SomeData : public IPower
{
public:
  SomeData(int x, int y, int z)
  {
    X = x;
    Y = y;
    Z = z;
  }

void Square()
{
  std::cout << "Square of the provided numbers are:\n";
  std::cout << X*X << std::endl;
  std::cout << Y*Y << std::endl;
  std::cout << Z*Z << std::endl;
}
void Cube()
{
  std::cout << "Cube of the provided numbers are:\n";
  std::cout << X*X*X << std::endl;
  std::cout << Y*Y*Y << std::endl;
  std::cout << Z*Z*Z << std::endl;
  
}
private:
  int X;
  int Y;
  int Z;
};

int main(){
    SomeData numbers(4,2,7);
    numbers.Square();
    numbers.Cube();
    return 0;
}

Expected Output :

Square of the provided numbers are:
16
4
49
Cube of the provided numbers are:
64
8
343

End of Demo 4.6
4.7   Polymorphism

The term Polymorphism means poly(many), morph(forms). Just as a human plays multiple roles simultaneously for example a man can play the role of a son, brother, spouse and father simultaneously, in each role the man performs separate duty. In programming, polymorphism stands for the same “entity” playing different roles when in need. In this section you will come across function overloading(the same function playing a different role), function overriding(redefining the same function in need) and operand overloading(same operand used with different data type) thus the topic is named Polymorphism.

C++ Polymorphism is mainly divided into two types:

    Run-time polymorphism
    Compile time polymorphism

Run-Time Polymorphism: Run Time Polymorphism is achieved by function overriding. Refer to Section 4.3 to revise the concept. Run Time Polymorphism mainly comprises of virtual function(section 4.4) which emphasises on late binding. By late binding or dynamic linkage, the compiler is informed about the selection of the function to be called at any given point in the program to be based on the kind of object for which it is called. It is called dynamic because a virtual function definition is not restricted to one definition of the function, it can be overridden using function overriding(section 4.3).

Compile-Time Polymorphism: This type of polymorphism is achieved by function overloading(section 4.3) and operator overloading. This type of polymorphism is also referred to as static binding or early binding. It takes place during compilation.

In this section, we will learn about operator overloading in detail. Operator Overloading: We can change the behaviour of operators for user-defined types like objects and structures. This process is called operator overloading.

Let’s overload the + operator to do more than add two numbers. How about using + add two objects? Let’s program and learn + operator overloading. Keep in mind 4 operators cannot be overloaded in C++. They are: :: (scope resolution) . (member selection) .* (member selection through pointer to function) ?: (ternary operator)
Demo 4.7

#include <iostream>
using namespace std;

class Complex {
    
   public:
    float real;
    float imag;

    // Constructor to initialize real and imag to 0
    Complex() : real(0), imag(0) {}

    
    // Overload the + operator
    Complex operator + (const Complex& obj) {
        Complex temp;
        temp.real = real + obj.real;
        temp.imag = imag + obj.imag;
        return temp;
    }

    void output() {
        if (imag < 0)
            cout << "Output Complex number: " << real << imag << "i\n";
        else
            cout << "Output Complex number: " << real << "+" << imag << "i\n";
    }
};

int main() {
    Complex complex1, complex2, result;
    complex1.real= 1;
    complex1.imag= 4;
    complex2.real = 4;
    complex2.imag= 1;

   // complex1 calls the operator function
   // complex2 is passed as an argument to the function
    result = complex1 + complex2;
    result.output();

    return 0;
}

Expected Output:

Output Complex number: 5+5i

End of Demo 4.7
4.8   Type Casting

Type Cast means changing the datatype of a variable. When a variable is typecast into a different type, the compiler treats the variable as the new data type. It is done to take advantage of certain features of type hierarchies or type representations. There are two types of typecasting:

    Implicit Typecasting(automatic)
    Explicit Typecasting(given)

Let’s implement and learn more about these two types:

Implicit Typecasting: In implicit or automatic casting compiler will automatically change one type of data into another. Typecasting can result in data loss(bear in mind before converting a larger datatype into a smaller one). Let’s convert float into integer implicitly.
Demo 4.8.1

#include<iostream>

int main(){

    float r = 4.23;
    int k =2;
    char a='a';
    int sum = k + r;
    std::cout<< "sum :"<< sum <<" Here r is typecasted to be an integer\n ";
    sum = sum + a;
    std::cout<< "sum :"<< sum <<" Here a is typecasted to be an integer, it's ASCII value is taken\n ";

    return 0;
}

Expected Output:

sum :6 Here r is typecasted to be an integer
sum :103 Here a is typecasted to be an integer, it's ASCII value is taken

End of Demo 4.8.1

Explicit Typecasting: Explicit because this typecasting is user-defined. Here the user can typecast the result to make it of a particular data type.

a) Conversion by assignment: This is done by explicitly defining the required type in front of the expression in parenthesis. This can be also considered as forceful casting. Syntax: (type) expression where type indicates the data type to which the final result is converted. b) Using Type casting operators- There are 4 possibilities of cast operators:

i) const_cast :(Removes/Undo constant nature of the variable) const_cast can be used to change non-const class members inside a const member function. The target type must be the same as the source type except for the alteration of its const or volatile attributes. This type of casting manipulates the const attribute of the passed object, either to be set or removed. Syntax: const_cast (expression);

ii)static_cast: (Compile-time casting)The static_cast alter the constness behaviour of an object, either to be set or to be removed. The static_cast operator performs the casting of pointers to related classes. It can perform conversion from a derived class to its base as well as from a base class to its derived. Syntax: static_cast (expression);

iii) dynamic_cast(Run time casting, mainly used with pointer): Dynamic cast is used to perform conversion of one type variable to another only on class pointers and references. It checks the valid casting of the variables at the run time, and if the casting fails, it returns a NULL value. Syntax: dynamic_cast (expression);

iv)reinterpret_cast(To change the data type of pointers): It is used to convert a pointer of some data type into a pointer of another data type. It does not check if the pointer type and data pointed by the pointer is the same or not. Syntax: reinterpret_cast (expression);
Demo 4.8.2

#include <iostream>

void func(int* u){
    std::cout << "Output of constant cast " << *u << std::endl;
}

class Base{
    virtual void print(){}
};
class derived : public Base{
};
int main()
{
    // using static cast operator
    float f = 3.5;
    int b = static_cast<int>(f);
    std::cout << "Output of static cast " << b << std::endl;

    // using constant cast operator
    const int num1 = 40;
    const int *num2 = &num1;
    
    // typecasting to pass a pointer to constant data type variable
    int *v = const_cast <int*>(num2);
    func(v);

    // using dynamic cast operator
    Base *ptr = new derived;
    
    // converting pointer to parent into pointer to child class
    derived *pd = dynamic_cast<derived*>(ptr);
    
    if(pd!=NULL){
        std::cout << "Dynamic casting is done successfully" << std::endl;
    }
    else{
    std::cout<< "Dynamic casting has failed" << std::endl;
    }

    // using reinterpret cast operator
    // declare a pointer variable
    int *pt = new int (65);
    
    // converting int pointer type to char pointer type
    char *ch = reinterpret_cast <char*>(pt);
    std::cout << "The value of pt is "<< pt << ", value of pt* is "<< *pt << std::endl;
    std::cout << "The value of ch is "<< ch << ", value of ch* is "<< *ch << std::endl;

    return 0;
}

Expected output:

Output of static cast 3
Output of constant cast 40
Dynamic casting is done successfully
The value of pt is 0x55edd8a432e0, value of pt* is 65
The value of ch is A, value of ch* is A

End of Demo 4.8.2

I hope you enjoyed the unit. Stay tuned for more advanced cpp content. Keep pushing your ROS learning!
